diff --git a/dist/esm/index.mjs b/dist/esm/index.mjs
index 75d7d767f0104d3900ce3fa7a76d5dc7a4689e82..69dd29c7b29a88c5379c2af6bf2e49585000e609 100755
--- a/dist/esm/index.mjs
+++ b/dist/esm/index.mjs
@@ -2,4 +2,4 @@ import{isMainThread as F}from"worker_threads";import{i as w,a as v,m as M}from".
 The --loader flag was deprecated in Node v20.6.0 and v18.19.0`)},B=()=>`
 const require = getBuiltin('module').createRequire("${import.meta.url}");
 require('../source-map.cjs').installSourceMapSupport();
-`,d=async(t,r,o)=>{const e=await t(r,o);return!e.format&&e.url.startsWith(k)&&(e.format=await Q(e.url)),e},V=[".js",".json",".ts",".tsx",".jsx"],l=async(t,r,o)=>{const[e,a]=t.split("?");let i;for(const n of V)try{return await d(o,e+n+(a?`?${a}`:""),r)}catch(s){if(i===void 0&&s instanceof Error){const{message:c}=s;s.message=s.message.replace(`${n}'`,"'"),s.stack=s.stack.replace(c,s.message),i=s}}throw i},j=async(t,r,o)=>{const e=S.test(t),a=e?"index":"/index",[i,n]=t.split("?");try{return await l(i+a+(n?`?${n}`:""),r,o)}catch(s){if(!e)try{return await l(t,r,o)}catch{}const c=s,{message:m}=c;throw c.message=c.message.replace(`${a.replace("/",f.sep)}'`,"'"),c.stack=c.stack.replace(m,c.message),c}},Y=/^\.{1,2}\//,O=async(t,r,o,e)=>{var a;if(S.test(t))return await j(t,r,o);const i=t.startsWith(k)||Y.test(t);if(E&&!i&&!((a=r.parentURL)!=null&&a.includes("/node_modules/"))){const n=E(t);for(const s of n)try{return await O(U(s).toString(),r,o)}catch{}}if(h.test(r.parentURL)){const n=J(t);if(n)for(const s of n)try{return await d(o,s,r)}catch(c){const{code:m}=c;if(m!=="ERR_MODULE_NOT_FOUND"&&m!=="ERR_PACKAGE_PATH_NOT_EXPORTED")throw c}}try{return await d(o,t,r)}catch(n){if(n instanceof Error&&!e){const{code:s}=n;if(s==="ERR_UNSUPPORTED_DIR_IMPORT")try{return await j(t,r,o)}catch(c){if(c.code!=="ERR_PACKAGE_IMPORT_NOT_DEFINED")throw c}if(s==="ERR_MODULE_NOT_FOUND")try{return await l(t,r,o)}catch{}}throw n}};let g;b.then(t=>{g=t},()=>{});const y=w(v)?"importAttributes":"importAssertions",Z=async(t,r,o)=>{var e;g&&g({type:"dependency",path:t}),X.test(t)&&(r[y]||(r[y]={}),r[y].type="json");const a=await o(t,r);if(!a.source)return a;const i=t.startsWith("file://")?P(t):t,n=a.source.toString();if(a.format==="json"||h.test(t)){const s=await D(n,i,{tsconfigRaw:(e=H)==null?void 0:e(i)});return{format:"module",source:R(s)}}if(a.format==="module"){const s=A(i,n);s&&(a.source=R(s))}return a};w(M)&&F&&C();export{B as globalPreload,z as initialize,Z as load,O as resolve};
+`,d=async(t,r,o)=>{const e=await t(r,o);return!e.format&&e.url.startsWith(k)&&(e.format=await Q(e.url)),e},V=[".js",".json",".ts",".tsx",".jsx"],l=async(t,r,o)=>{const[e,a]=t.split("?");let i;for(const n of V)try{return await d(o,e+n+(a?`?${a}`:""),r)}catch(s){if(i===void 0&&s instanceof Error){const{message:c}=s;s.message=s.message.replace(`${n}'`,"'"),s.stack=s.stack.replace(c,s.message),i=s}}throw i},j=async(t,r,o)=>{const e=S.test(t),a=e?"index":"/index",[i,n]=t.split("?");try{return await l(i+a+(n?`?${n}`:""),r,o)}catch(s){if(!e)try{return await l(t,r,o)}catch{}const c=s,{message:m}=c;throw c.message=c.message.replace(`${a.replace("/",f.sep)}'`,"'"),c.stack=c.stack.replace(m,c.message),c}},Y=/^\.{1,2}\//,O=async(t,r,o,e)=>{var a;if(S.test(t))return await j(t,r,o);const i=t.startsWith(k)||Y.test(t);if(E&&!i&&!((a=r.parentURL)!=null&&a.includes("/node_modules/"))){const n=E(t);for(const s of n)try{return await O(U(s).toString(),r,o)}catch{}}if(h.test(r.parentURL)){const n=J(t);if(n)for(const s of n)try{return await d(o,s,r)}catch(c){const{code:m}=c;if(m!=="ERR_MODULE_NOT_FOUND"&&m!=="ERR_PACKAGE_PATH_NOT_EXPORTED")throw c}}try{return await d(o,t,r)}catch(n){if(n instanceof Error&&!e){const{code:s}=n;if(s==="ERR_UNSUPPORTED_DIR_IMPORT")try{return await j(t,r,o)}catch(c){if(c.code!=="ERR_PACKAGE_IMPORT_NOT_DEFINED")throw c}if(s==="ERR_MODULE_NOT_FOUND")try{return await j(t,r,o)}catch{}}throw n}};let g;b.then(t=>{g=t},()=>{});const y=w(v)?"importAttributes":"importAssertions",Z=async(t,r,o)=>{var e;g&&g({type:"dependency",path:t}),X.test(t)&&(r[y]||(r[y]={}),r[y].type="json");const a=await o(t,r);if(!a.source)return a;const i=t.startsWith("file://")?P(t):t,n=a.source.toString();if(a.format==="json"||h.test(t)){const s=await D(n,i,{tsconfigRaw:(e=H)==null?void 0:e(i)});return{format:"module",source:R(s)}}if(a.format==="module"){const s=A(i,n);s&&(a.source=R(s))}return a};w(M)&&F&&C();export{B as globalPreload,z as initialize,Z as load,O as resolve};
